Algorytm gÄ…sianicy sÅ‚uÅ¼y do znalezienia w ciÄ…gu spÃ³jnego podciÄ…gu o danej sumie (itp). MoÅ¼emy prÃ³bowaÄ‡ znaleÅºÄ‡ najmniejszy taki ciÄ…g, najwiÄ™kszy lub dowolny (pod wzglÄ™dem dÅ‚ugoÅ›ci). OczywiÅ›cie moÅ¼na algorytm modyfikowaÄ‡ wedÅ‚ug wÅ‚asnych potrzeb (tak jak zresztÄ… kaÅ¼dy algorytm).

Algorytm
W czasie algorytmu bÄ™dziemy wykonywaÄ‡ ruchy "gÄ…sienicy". Poruszamy albo gÅ‚owÄ…, algo ogonem. GÅ‚owa opisuje nam koniec aktualnie rozpatrywanego przedziaÅ‚u, a ogon jego poczÄ…tek. JeÅ¼eli chcemy osiÄ…gnÄ…Ä‡ przedziaÅ‚ o sumie k, to bÄ™dziemy przesuwaÄ‡ nasze kraÅ„ce w taki sposÃ³b:
JeÅ¼eli suma w rozpatrywanym przedziale jest za maÅ‚a, to przesuwamy gÅ‚owÄ™ (do przodu)
JeÅ¼eli suma w rozpatrywanym przedziale jest za duÅ¼a, to przesuwamy ogon (do przodu)
JeÅ¼eli suma w rozpatrywanym przedziale jest idealna, to super! Odnotowujemy ten fakt i odpowiednio ustawiamy wynik. NastÄ™pnym ruchem bÄ™dzie przesuniÄ™cie gÅ‚owy.
oczywiÅ›cie w tym przypadku wartoÅ›ci w ciÄ…gu muszÄ… byÄ‡ nieujemne ğŸ˜‰.

PrzykÅ‚ad
Zasymulujmy nasz algorytm na takim przykÅ‚adzie:
Mamy znaleÅºÄ‡ najkrÃ³tszy fragment w ciÄ…gu 1 4 5 3 7 2 o sumie 10. (zielony kolor oznacza fragment wyznaczany przez gÅ‚owÄ™ i ogon)
1 4 5 3 7 2 suma jest mniejsza od 10, wiÄ™c przesuwamy gÅ‚owÄ™
1 4 5 3 7 2 suma jest mniejsza od 10, wiÄ™c przesuwamy gÅ‚owÄ™
1 4 5 3 7 2 suma jest rÃ³wna 10, wiÄ™c teraz naszym wynikiem jest 3(dÅ‚ugoÅ›Ä‡ podciÄ…gu, a Å¼e wczeÅ›niej Å¼adnego podciÄ…gu o sumie 10 nie znaleÅºliÅ›my, to wynikiem bÄ™dzie ten znaleziony teraz)
1 4 5 3 7 2 suma jest wiÄ™ksza od 10, wiÄ™c przesuwamy ogon
1 4 5 3 7 2 suma jest wiÄ™ksza od 10, wiÄ™c przesuwamy ogon
1 4 5 3 7 2 suma jest mniejsza od 10, wiÄ™c przesuwamy gÅ‚owÄ™
1 4 5 3 7 2 suma jest wiÄ™ksza od 10, wiÄ™c przesuwamy ogon
1 4 5 3 7 2 suma jest rÃ³wna 10. WczeÅ›niej mieliÅ›my wynik 3, teraz mielibyÅ›my wynik 2, wiÄ™c teraz naszym wynikiem jest 2.
1 4 5 3 7 2 suma jest wiÄ™ksza od 10, wiÄ™c przesuwamy ogon
1 4 5 3 7 2 suma jest mniejsza od 10, ale gÅ‚owy nie mamy juÅ¼ gdzie przesunÄ…Ä‡, wiÄ™c koÅ„czymy algorytm. Wynikiem jego dziaÅ‚ania dla tego przykÅ‚adu bÄ™dzie 2.

Implementacja i zÅ‚oÅ¼onoÅ›Ä‡
implementacja w c++:
int wagony[2000010];

int gasienica(int n, int ilec){
int wyn = 1000000010, glowa = 0, ogon = 1, akt_sum = 0;
while(glowa < n){
glowa++;
akt_sum += wagony[glowa];
if(akt_sum < ilec){
continue;
}
if(akt_sum == ilec){
wyn = min(wyn, glowa - ogon + 1);
}
while(ogon < glowa && akt_sum>= ilec){
akt_sum -= wagony[ogon];
ogon++;
if(akt_sum == ilec){
wyn = min(wyn, glowa - ogon + 1);
}
}
}
return wyn;
}